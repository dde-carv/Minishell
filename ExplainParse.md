The parsing component of your **minishell** project is designed to interpret and process the tokens generated by the tokenizer, constructing an Abstract Syntax Tree (AST) that represents the command structure. Here's a detailed breakdown of how the parsing works based on the provided code excerpts:

## Overview

The parsing process involves several steps:

1. **Tokenization**: Breaking the input command line into meaningful tokens.
2. **Parsing Tokens**: Analyzing the sequence of tokens to build an AST.
3. **Handling Syntax and Semantic Rules**: Ensuring the command structure is valid.
4. **Error Handling**: Managing and reporting parsing errors.

## Key Components

### 1. Data Structures

- ##### `t_token`  (include/tokenizing.h):
  ```c
  typedef struct s_token
  {
      t_token_type type;
      char *value;
      struct s_token *next;
  } t_token;
  ```

- ##### `t_node`  (include/parsing.h):
  ```c
  typedef struct s_node
  {
      t_node_type type;
      t_io_node *io_list;
      char *args;
      char **expanded_args;
      struct s_node *left;
      struct s_node *right;
  } t_node;
  ```

- ##### `t_minishell`  (include/minishell.h):
  ```c
  typedef struct s_minishell
  {
      char *line;
      t_token *tokens;
      t_token *curr_token;
      t_node *ast;
      int exit_s;
      bool signint_child;
      // ... other members ...
  } t_minishell;
  ```

### 2. Parsing Functions

#### `ft_parse` (parsing/parser.c)
Initiates the parsing process and constructs the AST.

```c
t_node *ft_parse(void)
{
    t_node *ast;

    g_minishell.curr_token = g_minishell.tokens;
    ast = ft_expression(0);
    if (g_minishell.curr_token)
        return (ft_set_parse_err(E_SYNTAX), ast);
    return (ast);
}
```

- **Description**: Starts parsing by setting the current token to the start of the token list. It calls `ft_expression` to handle expressions based on operator precedence. If there are leftover tokens after parsing, it sets a syntax error.

#### `ft_expression` (parsing/parser.c)
Handles expressions based on operator precedence.

```c
t_node *ft_expression(int min_prec)
{
    t_node *left;
    t_node *right;
    int n_prec;
    t_token_type op;

    if (g_minishell.parse_err.type || !g_minishell.curr_token)
        return (NULL);
    left = ft_term();
    if (!left)
        return (NULL);
    while (ft_curr_token_is_binop() && ft_curr_token_prec() >= min_prec)
    {
        op = g_minishell.curr_token->type;
        ft_get_next_token();
        if (!g_minishell.curr_token)
            return (ft_set_parse_err(E_SYNTAX), left);
        n_prec = ft_prec(op) + 1;
        right = ft_expression(n_prec);
        if (!right)
            return (left);
        left = ft_combine(op, left, right);
        if (!left)
            return (ft_clear_ast(&left), ft_clear_ast(&right), NULL);
    }
    return (left);
}
```

- **Description**: Recursively parses expressions, respecting operator precedence. It combines nodes based on the current operator.

#### `ft_term` (parsing/parser.c)
Parses individual terms in the expression.

```c
t_node *ft_term(void)
{
    t_node *node;

    if (g_minishell.parse_err.type)
        return (NULL);
    if (ft_curr_token_is_binop() || g_minishell.curr_token->type == T_C_PARENT)
        return (ft_set_parse_err(E_SYNTAX), NULL);
    else if (g_minishell.curr_token->type == T_O_PARENT)
    {
        ft_get_next_token();
        node = ft_expression(0);
        if (!node)
            return (NULL);
        if (!g_minishell.curr_token || g_minishell.curr_token->type != T_C_PARENT)
            return (ft_set_parse_err(E_SYNTAX), node);
        ft_get_next_token();
        return (node);
    }
    else
        return (ft_get_simple_cmd());
}
```

- **Description**: Determines whether the term is a sub-expression (enclosed in parentheses) or a simple command. It handles the opening and closing of parentheses and delegates to `ft_get_simple_cmd` for command parsing.

#### `ft_get_simple_cmd` (parsing/parser_helpers.c)
Parses simple commands without any operators.

```c
t_node *ft_get_simple_cmd(void)
{
    t_node *node;

    if (g_minishell.parse_err.type)
        return (NULL);
    node = ft_new_node(N_CMD);
    if (!node)
        return (ft_set_parse_err(E_MEM), NULL);
    while (g_minishell.curr_token
        && (g_minishell.curr_token->type == T_IDENTIFIER
            || ft_is_redir(g_minishell.curr_token->type)))
    {
        if (g_minishell.curr_token->type == T_IDENTIFIER)
        {
            if (!ft_join_args(&(node->args)))
                return (ft_clear_cmd_node(node), ft_set_parse_err(E_MEM), NULL);
        }
        else if (ft_is_redir(g_minishell.curr_token->type))
        {
            if (!ft_get_io_list(&(node->io_list)))
                return (free(node->args), free(node), NULL);
        }
    }
    return (node);
}
```

- **Description**: Creates a new command node and populates it with arguments and I/O redirections by iterating through the tokens.

#### `ft_combine` (parsing/parser.c)
Combines two nodes with an operator.

```c
t_node *ft_combine(t_token_type op, t_node *left, t_node *right)
{
    t_node *node;

    if (g_minishell.parse_err.type)
        return (NULL);
    node = ft_new_node(ft_get_node_type(op));
    if (!node)
        return (ft_set_parse_err(E_MEM), NULL);
    node->left = left;
    node->right = right;
    return (node);
}
```

- **Description**: Creates a new AST node representing the operator and attaches the left and right subtrees.

### 3. Helper Functions

#### `ft_is_redir` (parsing/parser_utils.c)
Checks if a token is a redirection.

```c
bool ft_is_redir(t_token_type type)
{
    if (type == T_LESS || type == T_GREAT
        || type == T_DLESS || type == T_DGREAT)
        return (true);
    return (false);
}
```

#### `ft_curr_token_is_binop` (parsing/parser_utils.c)
Determines if the current token is a binary operator.

```c
bool ft_curr_token_is_binop(void)
{
    t_token_type type;

    if (!g_minishell.curr_token)
        return (false);
    type = g_minishell.curr_token->type;
    if (type == T_PIPE || type == T_AND || type == T_OR)
        return (true);
    return (false);
}
```

#### `ft_prec` (parsing/parser_utils.c)
Returns the precedence of an operator.

```c
int ft_prec(t_token_type type)
{
    if (type == T_OR || type == T_AND)
        return (0);
    return (1);
}
```

- **Precedence Levels**:
  -

T_OR , T_AND: Lower precedence (`0`)

T_PIPE: Higher precedence (`1`)

### 4. Error Handling

#### `ft_set_parse_err` (parsing/parser_err.c)
Sets the current parsing error.

```c
void ft_set_parse_err(t_parse_err_type type)
{
    g_minishell.parse_err.type = type;
}
```

#### `ft_handle_parse_err` (parsing/parser_err.c)
Handles and reports parsing errors.

```c
void ft_handle_parse_err(void)
{
    t_parse_err_type type;
    t_token_type token_type;
    char **types;

    types = (char *[]){"T_IDENTIFIER",
        "<", ">", "<<", ">>", "|", "(", ")", "&&", "||", "newline"};
    type = g_minishell.parse_err.type;
    if (type)
    {
        if (type == E_SYNTAX)
        {
            if (!g_minishell.curr_token)
                token_type = T_NL;
            else
                token_type = g_minishell.curr_token->type;
            ft_putstr_fd("minishell: syntax error near unexpected token `", 2);
            ft_putstr_fd(types[token_type], 2);
            ft_putstr_fd("'\n", 2);
            g_minishell.exit_s = 258;
        }
        ft_clear_ast(&g_minishell.ast);
        ft_bzero(&g_minishell.parse_err, sizeof(t_parse_err));
    }
}
```

- **Description**: Checks the type of parsing error and prints an appropriate error message. It also clears the AST and resets the error state.

### 5. AST Clearing

#### `ft_clear_ast` (parsing/parser_clear.c)
Clears the AST to free memory.

```c
void ft_clear_ast(t_node **ast)
{
    ft_recursive_clear_ast(*ast);
    *ast = NULL;
    ft_clear_token_list(&g_minishell.tokens);
}
```

#### `ft_recursive_clear_ast` (parsing/parser_clear.c)
Recursively frees AST nodes.

```c
void ft_recursive_clear_ast(t_node *node)
{
    if (!node)
        return;
    if (node->type == N_CMD)
        ft_clear_cmd_node(node);
    else
    {
        if (node->left)
            ft_recursive_clear_ast(node->left);
        if (node->right)
            ft_recursive_clear_ast(node->right);
    }
    free(node);
}
```

- **Description**: Traverses the AST and frees memory for each node and its associated data.

## Parsing Workflow

1. **Initialization**: The parser starts by setting the current token to the beginning of the token list.
2. **Expression Parsing**: `ft_expression` handles expressions based on operator precedence, allowing for nested and compound commands.
3. **Term Parsing**: Within expressions, `ft_term` differentiates between sub-expressions (enclosed in parentheses) and simple commands.
4. **Command Parsing**: `ft_get_simple_cmd` constructs command nodes, handling arguments and I/O redirections.
5. **AST Construction**: Nodes are combined using `ft_combine` to build the AST reflecting the command structure and operators.
6. **Error Detection**: Throughout parsing, errors are detected and handled using `ft_set_parse_err` and `ft_handle_parse_err`.
7. **Memory Management**: Upon encountering errors or completing parsing, the AST and tokens are appropriately cleared to manage memory.

## Token Types and Operators

- **Identifiers**: Represent command names and arguments (T_IDENTIFIER).
- **Redirections**: Input (`<`,T_LESS), output (`>`,T_GREAT), append (`>>`,T_DGREAT), and heredoc (`<<`,T_DLESS).
- **Operators**: Pipe (`|`,T_PIPE), logical AND (`&&`,T_AND), and logical OR (`||`,T_OR).
- **Parentheses**: For grouping commands (`(`,T_O_PARENT; `)`,T_C_PARENT).

## Error Codes

- **`E_MEM`**: Memory allocation failure.
- **`E_SYNTAX`**: Syntax error detected during parsing.

## Example Parsing Process

Consider the command:

```sh
echo "Hello World" && ls -la | grep "minishell"
```

1. **Tokenization**:
   - `echo` (T_IDENTIFIER)
   - `"Hello World"` (T_IDENTIFIER)
   - `&&` (T_AND)
   - `ls` (T_IDENTIFIER)
   - `-la` (T_IDENTIFIER)
   - `|` (T_PIPE)
   - `grep` (T_IDENTIFIER)
   - `"minishell"` (T_IDENTIFIER)

2. **Parsing**:
   - `ft_parse` initializes parsing.
   - `ft_expression` with `min_prec = 0` handles `echo "Hello World"`.
   - Encounters `&&`, which has precedence `0`. Proceeds to parse the right-hand side.
   - `ft_expression` parses `ls -la | grep "minishell"`.
   - `ft_pipe` operator (`|`) with higher precedence `1` connects `ls -la` and `grep "minishell"`.
   - The AST reflects the logical AND connecting the two command pipelines.

3. **AST Structure**:
   ```
           AND
          /   \
     echo "Hello World"  PIPE
                         /   \
                    ls -la  grep "minishell"
   ```

## Conclusion

The parsing system in your **minishell** project systematically processes tokens to build an AST that accurately represents the structure and hierarchy of shell commands. It handles various operators and redirections, ensures syntax correctness, and manages errors effectively. The modular design with clear separation of concerns facilitates maintenance and scalability.

For more detailed insights into specific functions or further assistance, feel free to ask!
